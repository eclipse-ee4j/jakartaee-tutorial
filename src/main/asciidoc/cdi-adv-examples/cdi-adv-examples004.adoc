== The producerfields Example: Using Producer Fields to Generate Resources

The `producerfields` example, which allows you to create a to-do list, shows how to use a producer field to generate objects that can then be managed by the container.
This example generates an `EntityManager` object, but resources such as JDBC connections and datasources can also be generated this way.

The `producerfields` example is the simplest possible entity example.
It also contains a qualifier and a class that generates the entity manager.
It also contains a single entity, a stateful session bean, a Facelets page, and a managed bean.

The source files are located in the `_tut-install_/examples/cdi/producerfields/src/main/java/ee/jakarta/tutorial/producerfields/` directory.

=== The Producer Field for the producerfields Example

The most important component of the `producerfields` example is the smallest, the `db.UserDatabaseEntityManager` class, which isolates the generation of the `EntityManager` object so it can easily be used by other components in the application.
The class uses a producer field to inject an `EntityManager` annotated with the `@UserDatabase` qualifier, also defined in the `db` package:

[source,java]
----
@Singleton
public class UserDatabaseEntityManager {

    @Produces
    @PersistenceContext
    @UserDatabase
    private EntityManager em;
    ...
}
----

The class does not explicitly produce a persistence unit field, but the application has a `persistence.xml` file that specifies a persistence unit.
The class is annotated `jakarta.inject.Singleton` to specify that the injector should instantiate it only once.

The `db.UserDatabaseEntityManager` class also contains commented-out code that uses `create` and `close` methods to generate and remove the producer field:

[source,java]
----
/* 
@PersistenceContext
private EntityManager em;

@Produces
@UserDatabase
public EntityManager create() {
    return em;
} 
*/

public void close(@Disposes @UserDatabase EntityManager em) {
    em.close();
}
----

You can remove the comment indicators from this code and place them around the field declaration to test how the methods work.
The behavior of the application is the same with either mechanism.

The advantage of producing the `EntityManager` in a separate class rather than simply injecting it into an enterprise bean is that the object can easily be reused in a typesafe way.
Also, a more complex application can create multiple entity managers using multiple persistence units, and this mechanism isolates this code for easy maintenance, as in the following example:

[source,java]
----
@Singleton
public class JPAResourceProducer {
    @Produces
    @PersistenceUnit(unitName="pu3")
    @TestDatabase
    EntityManagerFactory customerDatabasePersistenceUnit;

    @Produces
    @PersistenceContext(unitName="pu3")
    @TestDatabase
    EntityManager customerDatabasePersistenceContext;

    @Produces
    @PersistenceUnit(unitName="pu4")
    @Documents
    EntityManagerFactory customerDatabasePersistenceUnit;

    @Produces
    @PersistenceContext(unitName="pu4")
    @Documents
    EntityManager docDatabaseEntityManager;
}
----

The `EntityManagerFactory` declarations also allow applications to use an application-managed entity manager.

=== The producerfields Entity and Session Bean

The `producerfields` example contains a simple entity class, `entity.ToDo`, and a stateful session bean, `ejb.RequestBean`, that uses it.

The entity class contains three fields: an autogenerated `id` field, a string specifying the task, and a timestamp.
The timestamp field, `timeCreated`, is annotated with `@Temporal`, which is required for persistent `Date` fields.

[source,java]
----
@Entity
public class ToDo implements Serializable {

    ...
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    protected String taskText;
    @Temporal(TIMESTAMP)
    protected Date timeCreated;

    public ToDo() {
    }

    public ToDo(Long id, String taskText, Date timeCreated) {
        this.id = id;
        this.taskText = taskText;
        this.timeCreated = timeCreated;
    }
    ...
}
----

The remainder of the `ToDo` class contains the usual getters, setters, and other entity methods.

The `RequestBean` class injects the `EntityManager` generated by the producer method, annotated with the `@UserDatabase` qualifier:

[source,java]
----
@ConversationScoped
@Stateful
public class RequestBean {

    @Inject
    @UserDatabase
    EntityManager em;
}
----

It then defines two methods, one that creates and persists a single `ToDo` list item, and another that retrieves all the `ToDo` items created so far by creating a query:

[source,java]
----
public ToDo createToDo(String inputString) {
    ToDo toDo = null;
    Date currentTime = Calendar.getInstance().getTime();

    try {
        toDo = new ToDo();
        toDo.setTaskText(inputString);
        toDo.setTimeCreated(currentTime);
        em.persist(toDo);
        return toDo;
    } catch (Exception e) {
        throw new EJBException(e.getMessage());
    }
}

public List<ToDo> getToDos() {
    try {
            List<ToDo> toDos =
                (List<ToDo>) em.createQuery(
                "SELECT t FROM ToDo t ORDER BY t.timeCreated")
                .getResultList();
        return toDos;
    } catch (Exception e) {
        throw new EJBException(e.getMessage());
    }
}
----

=== The producerfields Facelets Pages and Managed Bean

The `producerfields` example has two Facelets pages, `index.xhtml` and `todolist.xhtml`.
The simple form on the `index.xhtml` page asks the user only for the task.
When the user clicks the Submit button, the `listBean.createTask` method is called.
When the user clicks the Show Items button, the action specifies that the `todolist.xhtml` file should be displayed:

[source,xml]
----
    <h:body>
        <h2>To Do List</h2>
        <p>Enter a task to be completed.</p>
        <h:form id="todolist">
            <p><h:outputLabel value="Enter a string: " for="inputString"/>
                <h:inputText id="inputString"
                             value="#{listBean.inputString}"/></p>
            <p><h:commandButton value="Submit"
                                action="#{listBean.createTask()}"/></p>
            <p><h:commandButton value="Show Items"
                                action="todolist"/></p>
        </h:form>
        ...
    </h:body>
----

The managed bean, `web.ListBean`, injects the `ejb.RequestBean` session bean.
It declares the `entity.ToDo` entity and a list of the entity along with the input string that it passes to the session bean.
The `inputString` is annotated with the `@NotNull` Bean Validation constraint, so an attempt to submit an empty string results in an error.

[source,java]
----
@Named
@ConversationScoped
public class ListBean implements Serializable {

    ...
    @EJB
    private RequestBean request;
    @NotNull
    private String inputString;
    private ToDo toDo;
    private List<ToDo> toDos;
    ...
}
----

The `createTask` method called by the Submit button calls the `createToDo` method of `RequestBean`:

[source,java]
----
public void createTask() {
    this.toDo = request.createToDo(inputString);
}
----

The `getToDos` method, which is called by the `todolist.xhtml` page, calls the `getToDos` method of `RequestBean`:

[source,java]
----
public List<ToDo> getToDos() {
    return request.getToDos();
}
----

To force the Facelets page to recognize an empty string as a null value and return an error, the `web.xml` file sets the context parameter `jakarta.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL` to `true`:

[source,xml]
----
<context-param>
  <param-name>jakarta.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL</param-name>
  <param-value>true</param-value>
</context-param>
----

The `todolist.xhtml` page is a little more complicated than the `index.html` page.
It contains a `dataTable` element that displays the contents of the `ToDo` list.
The body of the page looks like this:

[source,xml]
----
    <body>
        <h2>To Do List</h2>
        <h:form id="showlist">
            <h:dataTable var="toDo"
                         value="#{listBean.toDos}"
                         rules="all"
                         border="1"
                         cellpadding="5">
                <h:column>
                    <f:facet name="header">
                        <h:outputText value="Time Stamp" />
                    </f:facet>
                    <h:outputText value="#{toDo.timeCreated}" />
                </h:column>
                <h:column>
                    <f:facet name="header">
                        <h:outputText value="Task" />
                    </f:facet>
                    <h:outputText value="#{toDo.taskText}" />
                </h:column>
            </h:dataTable>
            <p><h:commandButton id="back" value="Back" action="index" /></p>
        </h:form>
    </body>
----

The value of the `dataTable` is `listBean.toDos`, the list returned by the managed bean's `getToDos` method, which in turn calls the session bean's `getToDos` method.
Each row of the table displays the `timeCreated` and `taskText` fields of the individual task.
Finally, a Back button returns the user to the `index.xhtml` page.

=== Running the producerfields Example

You can use either NetBeans IDE or Maven to build, package, deploy, and run the `producerfields` application.

==== To Build, Package, and Deploy the producerfields Example Using NetBeans IDE

. Make sure that GlassFish Server has been started (see <<starting-and-stopping-glassfish-server>>).

. If the database server is not already running, start it by following the instructions in <<starting-and-stopping-apache-derby>>.

. From the *File* menu, choose *Open Project*.

. In the *Open Project* dialog box, navigate to:
+
----
tut-install/examples/cdi
----

. Select the `producerfields` folder.

. Click *Open Project*.

. In the *Projects* tab, right-click the `producerfields` project and select *Build*.
+
This command builds and packages the application into a WAR file, `producerfields.war`, located in the `target` directory, and then deploys it to GlassFish Server.

==== To Build, Package, and Deploy the producerfields Example Using Maven

. Make sure that GlassFish Server has been started (see <<starting-and-stopping-glassfish-server>>).

. If the database server is not already running, start it by following the instructions in <<starting-and-stopping-apache-derby>>.

. In a terminal window, go to:
+
----
tut-install/examples/cdi/producerfields/
----

. Enter the following command to deploy the application:
+
[source,shell]
----
mvn install
----
+
This command builds and packages the application into a WAR file, `producerfields.war`, located in the `target` directory, and then deploys it to GlassFish Server.

==== To Run the producerfields Example

. In a web browser, enter the following URL:
+
----
http://localhost:8080/producerfields
----

. On the Create To Do List page, enter a string in the field and click Submit.
+
You can enter additional strings and click Submit to create a task list with multiple items.

. Click Show Items.
+
The To Do List page opens, showing the timestamp and text for each item you created.

. Click Back to return to the Create To Do List page.
+
On this page, you can enter more items in the list.
