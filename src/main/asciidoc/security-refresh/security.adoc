= Jakarta Security

Jakarta Security is the overarching security API in Jakarta EE. 

Due to historical and political reasons, a number of security features are distributed among several other APIs in Jakarta EE. Sometimes they overlap, sometimes such features are only accessible from these other APIs. In this chapter we will focus primarily on explaining Jakarta Security, and will mention when other APIs are needed to accomplish a certain task.

== Overview

Before we look at some practical examples, let's quickly go through some basics. 

Some of the guiding principles in Jakarta Security are:

1. It should work directly out of the box, without requiring any kind of vendor specific configuration or activation.
2. It leverages Jakarta CDI as much as possible. Most artefacts are CDI beans and many features are done via CDI interceptors.
3. The difference between framework provided artefacts and custom (user provided) artefacts is minimal or non-existent.
4. It fully integrates with security features from other Jakarta EE APIs and proprietary (vendor specific) artefacts.

Jakarta Security makes an important distinction between several distinct artefacts that play an important role in the security process:

1. The Authentication Mechanism
2. The Identity Store
3. The Permission Store

The first two of these are used in the authentication process:

An _authentication mechanism_ is somewhat like a controller in the well-known MVC pattern; itâ€™s the entity that interacts with the caller (typically a human) via some kind of view to collect credentials and with the model (business logic) to validate these credentials. An authentication mechanism knows about the environment that this caller uses to communicate with the server. An authentication mechanism for HTTP knows about URLs to redirect or forward to, or about response headers to send to the client. It also knows about the data coming back, such as cookies, request headers, and post data. Examples of authentication mechanisms are FORM authentication and BASIC authentication.

An _identity store_ on its turn is more like the model in the MVC pattern. This entity strictly performs a business / data operation where credentials go in, and an identity comes out. The identity contains logic to validate said credentials, and embeds or contacts a database. This "database" contains user names, along with their credentials and (typically) roles. An identity store therefore knows nothing about the environment that this caller uses to communicate with the server; e.g. it doesn't know about HTTP or headers etc.
Example of identity stores are services that contact SQL/JDBC databases, LDAP servers, files on the file-system, etc.


image::authentication_mvc.svg["Diagram illustrating the role of the authentication mechanism and identity store in an MVC like structure"]

The third one is used for the authorization process:

A _permission store_ is another kind of model that stores permissions, typically either globally, or per role (role based permissions). This entity then performs a business / data operation where a query and an identity go in, and a yes/no answer goes out. For instance, a query such as "can access /foo/bar" along with the identity for user "John" with roles "bar" and "kaz".
Examples of permissions stores are the Jakarta Authorization usage of the Policy class, or the internal data structure where a Servlet Container such as Tomcat or Jetty stores the security constraints an application defined.


== Provided authentication mechanisms and identity stores 

Jakarta Security provides a number of build-in authentication mechanisms and identity stores. We'll enumerate them here first, and will look at them in more detail below.

Authentication mechanisms:

1. The Basic Authentication Mechanism
2. The Form Authentication Mechanism
3. The Custom Form Authentication Mechanism
4. The Open ID Connect (OIDC) Authentication Mechanism

Identity stores:

1. The Database Identity Store
2. The LDAP Identity Store

== Custom authentication mechanisms and identity stores 

When the provided authentication mechanisms and identity stores are not sufficient, we can easily define our own. The provided ones and our own ones use the exact same interfaces, and the system doesn't distinguish between calling our own one or one that was provided by the system.

== Authentication mechanisms and identity stores from other APIs

The Servlet specification defines the exact same Form and Basic authentication mechanisms. Authenticating with them will have the exact same result as authenticating with a Jakarta Security authentication mechanism. E.g. role checks will work exactly the same independent on which API was used to authenticate. 

A Servlet authentication mechanism however will not necessarily consult a Jakarta Security identity store. This is server dependent. The identity store that is called is server dependent as well. Calling this server dependent identity store is possible from Jakarta Security, but as an advanced feature.

Likewise, programmatic role checks can be done from various APIs, including Jakarta Security, Jakarta REST and Jakarta Servlet. These all return the same outcome, independent from whether authentication took place with a Jakarta Security Authentication Mechanism or a Servlet Authentication Mechanism.


== Securing an endpoint with Basic Authentication

In the following example we'll be securing a REST endpoint using Basic Authentication.

You'll learn the following things;

1. How to define security constraints
2. How to set a provided authentication mechanisms 
3. How to define (and implicitly set) a custom identity store
4. How to use the Jakarta Security SecurityContext

=== Write the application

Let's start with defining a simple REST resource class for a `/rest/resource` endpoint:

[source,java]
----
@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}
----

This resource uses the injected Jakarta EE SecurityContext to obtain access to the current authenticated caller, which is represented by a `Principal` instance. For simplicity sake the code here does not check whether the caller principal is `null`. If the resource is also available to non-authenticated callers, this is something we have to do. The `getCallerPrincipal()` call would return `null` then.

Also note that there is a Jakarta REST specific type that is also named `SecurityContext` and has similar methods as the ones we used here. From the point of view of Jakarta EE that is a deprecated type and replaced by the Jakarta Security version.

==== Declare the security constraints

Next we'll define the security constraints in `web.xml`, which are used to tell the security system that access to a given URL or URL pattern is protected, and hence authentication is required:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="5.0"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd">

    <security-constraint>
        <web-resource-collection>
            <web-resource-name>protected</web-resource-name>
            <url-pattern>/rest/*</url-pattern>
        </web-resource-collection>
        <auth-constraint>
            <role-name>user</role-name>
        </auth-constraint>
    </security-constraint>

</web-app>
----

This XML essentially says that to access any URL that starts with "/rest" requires the caller to have the role "user". Roles are opaque strings; merely identifiers. It's fully up to the application how broad or fine-grained they are.

Note that in Jakarta EE, internally these XML constraints are transformed into `Permission` instances and made available via a specific type of the Permission Store that we explained above. Knowledge about this transformation is only needed for very advanced use cases.

The observant reader may wonder if XML is really the only option here, given the strong feelings that exist in parts of the community around XML. The answer is yes and no. Jakarta EE does define the `@RolesAllowed` annotation that could be used to replace the XML shown above, but only the legacy Enterprise Beans has specified a behaviour for this when put on an Enterprise Bean. Jakarta REST has done no such thing, although the JWT API in MicroProfile has defined this for REST resources. In Jakarta EE however this remains a vendor specific extension.

There are also a number of annotations and APIs in Jakarta EE to set these kinds of constraints for individual Servlets, but those won't help us much either here.

==== Declare the authentication mechanism

[source,java]
----
@ApplicationScoped
@BasicAuthenticationMechanismDefinition(realmName = "basicAuth")
@DeclareRoles({ "user", "caller" })
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

}
----

To declare the usage of a specific authentication mechanism, Jakarta EE provides `[XYZ]MechanismDefinition` annotations. Such an annotation is picked up by the security system, and in response to it a CDI bean that implements the `HttpAuthenticationMechanism` is enabled for it.

The annotation can be put on any bean, but in a REST application it fits particularly well on the `Application` subclass that also declares the path for REST resources.

==== Define the identity store

Finally, let's define a very simple identity store that the security system can use to validate provided credentials for a Basic authentication:

[source,java]
----
@ApplicationScoped
public class TestIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("john", "secret1")) {
            return new CredentialValidationResult("john", Set.of("user", "caller"));
        }

        return INVALID_RESULT;
    }

}
----

This identity store only "contains" the single identity (user) "john", with password "secret1" and roles "user" and "caller". Defining this kind of identity store is often the simplest way to get started. Note that Jakarta Security does not define a simple identity store out of the box, because there are questions whether that would promote security best practices.

Also note that the identity store is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement `IdentityStore`. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn't matter for Jakarta Security, only the fact that it's there.


==== Test the application

It's now time to test our application. A ready to test version is available from the Jakarta EE Examples project at https://github.com/eclipse-ee4j/jakartaee-examples.

Download or clone this repo, then cd into the `focused` folder and execute:

```
mvn clean install -pl :restBasicAuthCustomStore
```

This will run a test associated with the project, printing something like the following:

```
john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.414 s - in jakartaee.examples.focused.security.restbasicauthcustomstore.RestBasicAuthCustomStoreIT
```

Let's take a quick look at the actual test:

[source,java]
----
@RunWith(Arquillian.class)
@RunAsClient
public class RestBasicAuthCustomStoreIT extends ITBase {

    /**
     * Stores the base URL.
     */
    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall() throws Exception {
        DefaultCredentialsProvider credentialsProvider = new DefaultCredentialsProvider();
        credentialsProvider.addCredentials("john", "secret1");

        webClient.setCredentialsProvider(credentialsProvider);

        TextPage page = webClient.getPage(baseUrl + "/rest/resource");
        String content = page.getContent();

        System.out.println(content);
    }
}
----

Using Arquillian, the test starts the default server (GlassFish 7), and deploys the actual output of the build process (a .war file) to it. The test runs in the integration test phase (and not the unit test phase) to make sure this output is indeed available. The test then does a request to the remote GlassFish server using a provided html unit web client. Note that anything that can do an HTTP request could have been used here as well.

The `DefaultCredentialsProvider` used here makes sure that the headers for Basic authentication are added to the request. The Basic authentication mechanism that we defined for our applications reads those headers, extracts the username and password from them, and consults our identity store with them.

Alternatively, we can manually deploy the war file found in `security/restBasicAuthCustomStore/target/restBasicAuthCustomStore.war` to a server of our choice (e.g. GlassFish 7), and request the URL via a browser or a commandline util such as `curl`.

== Securing an endpoint with Basic Authentication and a Database identity store

In the following example we'll be securing a REST endpoint using Basic Authentication and the database identity store that is provided by Jakarta Security.

You'll learn the following things;

1. How to define security constraints
2. How to set a provided authentication mechanisms 
3. How to set a provided identity store that uses a database
4. How to populate and configure that identity store 
5. How to use the Jakarta Security SecurityContext

=== Write the application

We'll use the same resource and same security constraints as we used for the <<Securing an endpoint with Basic Authentication>> example.

==== Declare the authentication mechanism and identity store

[source,java]
----
@ApplicationScoped
@BasicAuthenticationMechanismDefinition(
    realmName = "basicAuth"
)
@DatabaseIdentityStoreDefinition(
    callerQuery = "select password from basic_auth_user where username = ?",
    groupsQuery = "select name from basic_auth_group where username = ?",
    hashAlgorithmParameters = {
        "Pbkdf2PasswordHash.Iterations=3072",
        "Pbkdf2PasswordHash.Algorithm=PBKDF2WithHmacSHA512",
        "Pbkdf2PasswordHash.SaltSizeBytes=64"
    }
)
@DeclareRoles("user")
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

----

To declare the usage of a specific authentication mechanism, Jakarta EE provides `[XYZ]MechanismDefinition` annotations. Such an annotation is picked up by the security system, and in response to it a CDI bean that implements the `HttpAuthenticationMechanism` is enabled for it.

Likewise, to declare the usage of a specific identity store, Jakarta EE provides `[XYZ]StoreDefinition` annotations.

The annotations can be put on any bean, but in a REST application it fits particularly well on the `Application` subclass that also declares the path for REST resources.

In the case of the `DatabaseIdentityStoreDefinition` we need to provide it with at least two queries:

1. The SQL query that returns a password for the username part of credentials entered by a caller. The returned password is compared with the password part of those credentials. If they match (of more typically, their hashes match) the credential is considered valid.
2. The query that returns a number of roles given that same username part of the credentials

Although not required, it's a good practice to provide some parameters for the hash algorithm. Passwords should obviously never be stored in plain-text in a database.

Note that the provided `DatabaseIdentityStoreDefinition` is suited for to be paired with any authentication mechanism that validates username/password credentials.


==== Populating the identity store

In order to use the identity store we need to put some data in a database. The following code shows one way how to do that:


[source,java]
----
@ApplicationScoped
@BasicAuthenticationMechanismDefinition(
    realmName = "basicAuth"
)
@DatabaseIdentityStoreDefinition(
    callerQuery = "select password from basic_auth_user where username = ?",
    groupsQuery = "select name from basic_auth_group where username = ?",
    hashAlgorithmParameters = {
        "Pbkdf2PasswordHash.Iterations=3072",
        "Pbkdf2PasswordHash.Algorithm=PBKDF2WithHmacSHA512",
        "Pbkdf2PasswordHash.SaltSizeBytes=64"
    }
)
@DeclareRoles("user")
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

    /**
     * Id of the one and only user we populate in out DB.
     */
    private static final BigInteger USER_ID = ONE;

    /**
     * Id of the one and only group we populate in out DB.
     */
    private static final BigInteger GROUP_ID = ONE;

    @PersistenceContext
    private EntityManager entityManager;

    @Inject
    private Pbkdf2PasswordHash passwordHash;

    @Transactional
    public void onStart(@Observes @Initialized(ApplicationScoped.class) Object applicationContext) {
        passwordHash.initialize(Map.of(
            "Pbkdf2PasswordHash.Iterations", "3072",
            "Pbkdf2PasswordHash.Algorithm", "PBKDF2WithHmacSHA512",
            "Pbkdf2PasswordHash.SaltSizeBytes", "64"));

        if (entityManager.find(User.class, USER_ID) == null) {
            var user = new User();
            user.id  = USER_ID;
            user.username = "john";
            user.password = passwordHash.generate("secret1".toCharArray());
            entityManager.persist(user);
        }

        if (entityManager.find(Group.class, GROUP_ID) == null) {
            var group = new Group();
            group.id = GROUP_ID;
            group.name = "user";
            group.username = "john";
            entityManager.persist(group);
        }
    }

}

@Entity
@Table(name = "basic_auth_user")
class User {
    @Id
    BigInteger id;

    @Column(name = "password")
    String password;

    @Column(name = "username", unique = true)
    String username;
}

@Entity
@Table(name = "basic_auth_group")
class Group {
    @Column(name = "id")
    @Id
    BigInteger id;

    @Column(name = "name")
    String name;

    @Column(name = "username")
    String username;
}
----

The code above uses Jakarta Persistence, which generates SQL from java types. Jakarta Persistence is discussed in detail in its own chapter. For here it's important to note that the code takes advantage of the default datasource in Jakarta EE, so we don't have to explicitly install and configure an external database such as Postgres or MySQL. Without specifying a datasource, the `@DatabaseIdentityStoreDefinition` annotation defaults to using the default datasource, but if needed we can specify a different one using the `dataSourceLookup` attribute.

==== Test the application

It's now time to test our application. A ready to test version is available from the Jakarta EE Examples project at https://github.com/eclipse-ee4j/jakartaee-examples.

Download or clone this repo, then cd into the `focused` folder and execute:

```
mvn clean install -pl :restBasicAuthDBStore
```

This will run a test associated with the project, printing something like the following:

```
john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 8.307 s - in jakartaee.examples.focused.security.restbasicauthdbstore.RestBasicAuthDBStoreIT
```

The test itself is basically the same as that for the <<Securing an endpoint with Basic Authentication>> example.

