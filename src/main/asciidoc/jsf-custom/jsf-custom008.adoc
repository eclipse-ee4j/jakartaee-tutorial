== Handling Events for Custom Components

As explained in <<implementing-an-event-listener>>, events are
automatically queued on standard components that fire events. A custom
component, on the other hand, must manually queue events from its
`decode` method if it fires events.

<<performing-decoding>> explains how to queue an event on
`MapComponent` using its `decode` method. This section explains how to
write the class that represents the event of clicking on the map and
how to write the method that processes this event.

As explained in <<understanding-the-facelets-page>>, the
`actionListener` attribute of the `bookstore:map` tag points to the
`MapBookChangeListener` class. The listener class's `processAction`
method processes the event of clicking the image map. Here is the
`processAction` method:

[source,java]
----
@Override
public void processAction(ActionEvent actionEvent)
        throws AbortProcessingException {

    AreaSelectedEvent event = (AreaSelectedEvent) actionEvent;
    String current = event.getMapComponent().getCurrent();
    FacesContext context = FacesContext.getCurrentInstance();
    String bookId = books.get(current);
    context.getExternalContext().getSessionMap().put("bookId", bookId);
}
----

When the Jakarta Faces implementation calls this method, it passes in
an `ActionEvent` object that represents the event generated by clicking
on the image map. Next, it casts it to an `AreaSelectedEvent` object
(see
`_tut-install_/examples/case-studies/dukes-bookstore/src/java/dukesbookstore/listeners/AreaSelectedEvent.java`).
Then this method gets the `MapComponent` associated with the event.
Next, it gets the value of the `MapComponent` object's `current`
attribute, which indicates the currently selected area. The method then
uses the value of the `current` attribute to get the book's ID value
from a `HashMap` object, which is constructed elsewhere in the
`MapBookChangeListener` class. Finally, the method places the ID
obtained from the `HashMap` object into the session map for the
application.

In addition to the method that processes the event, you need the event
class itself. This class is very simple to write; you have it extend
`ActionEvent` and provide a constructor that takes the component on
which the event is queued and a method that returns the component. Here
is the `AreaSelectedEvent` class used with the image map:

[source,java]
----
public class AreaSelectedEvent extends ActionEvent {
    public AreaSelectedEvent(MapComponent map) {
        super(map);
    }
    public MapComponent getMapComponent() {
        return ((MapComponent) getComponent());
    }
}
----

As explained in the section <<creating-custom-component-classes>>, in
order for `MapComponent` to fire events in the first place, it must
implement `ActionSource`. Because `MapComponent` extends `UICommand`,
it also implements `ActionSource`.
